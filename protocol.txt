NOTICE:

- values are all big-endian
- ports:
	- M = main
	- S = starter
	- ? = sender
	- * = any


SERVER

loop
	recieve message
		if ping [RECV UDP:M Command::Ping]
			reply with status [SEND UDP:M->M HostStatus::Server(ServerStatus::Running)]
		if client connect [RECV UDP:M Command::Connect, x: f64, y: f64, rotation: f64, fov: f64]
			accept, add to clients
		if value update [RECV UDP:M Command::UpdateValue, value: f64]
			update value
			if all values updated
				calculate new position
				notify subscribers
		if info update [RECV UDP:M Command::UpdateInfo, x: f64, y: f64, rotation: f64, fov: f64]
kill all clients [SEND UDP:M->M Command::Kill]

CLIENT

outer loop
	wait for ping [RECV UDP:M Command::Ping]
	reply with status [SEND UDP:M->? HostStatus(ClientStatus::Idle)]
	wait for organizer start [RECV TCP:S Command::Start]
	connect to organizer TCP:S
	loop
		receive message
		if image request [RECV TCP:S Command::RequestImage]
   			send image from camera [SEND TCP:S->? len: u64, img: [u8]]
   			continue
		if done [RECV TCP:S Command::ImagesDone]
			break
	if calibrated
  		recieve camera info, server ip [RECV TCP:S x: f64, y: f64, rotation: f64, ip_len: u16, ip: [u8]]
 	if not calibrated
		recieve camera info, server ip, calibration [RECV TCP:S
			x: f64, y: f64, rotation: f64,
			ip_len: u16, ip: [u8],
			optimal_matrix: [f64; 9],
			camera_matrix: [f64; 9],
			distance_coefficients_len: u8,
			distance_coefficients: [f64]
		]
	connect [SEND UDP:M->M Command::Connect, x: f64, y: f64, rotation: f64, fov: f64]
	inner loop
		receive message
			if stop [RECV UDP:M Command::Stop]
				break (inner)
			if ping [RECV UDP:M Command::Ping]
				reply with status [SEND HostStatus(ClientStatus::Running)]
		find x value
		send value to server [SEND UDP:M->M Command::UpdateValue, value: f64]

CONFIGLESS CLIENT

outer loop
	wait for ping [RECV UDP:M Command::Ping]
	reply with status [SEND UDP:M->? HostStatus(ConfiglessClientStatus::Idle)]
	wait for organizer start + info [
		RECV TCP:S Command::StartConfigless,
		ip_len: u16, ip: [u8],
	]
	connect [SEND UDP:M->M Command::Connect, x: f64, y: f64, rotation: f64, fov: f64]
	inner loop
		receive message
			if stop [RECV UDP:M Command::Stop]
				break (inner)
			if ping [RECV UDP:M Command::Ping]
				reply with status [SEND HostStatus(ClientStatus::Running)]
		find x value
		send value to server [SEND UDP:M->M Command::UpdateValue, value: f64]
		if info changed
			send info update [SEND UDP:M->M Command::UpdateInfo, x: f64, y: f64, rotation: f64, fov: f64]

ORGANIZER

loop
	loop through ips
		send ping [SEND UDP:*->M Command::Ping]
		if offline
			continue
		if server [RECV UDP:* HostStatus::Server]
			set server ip
		if client [RECV UDP:* HostStatus::Client | HostStatus::ConfiglessClient]
			update client status
 get user action
	if client start
		send start [SEND UDP:*->M Command::Start]
		accept client connection TCP:S
		loop
			send image request [SEND TCP:*->S Command::RequestImage]
			recieve jpg image [RECV TCP:* len: u64, bytes: [u8]]
				show image to user
				if user wants to quit
					send stream stop [SEND TCP:*->S Command::ImagesDone]
		prompt user for position
		if calibrated
			send info [SEND TCP:*->S x: f64, y: f64, rotation: f64, ip_len: u16, ip: [u8]]
		else
			calibrate
			send info [SEND TCP:*->S
				x: f64, y: f64, rotation: f64,
				ip_len: u16, ip: [u8],
				optimal_matrix: [f64; 9],
				camera_matrix: [f64; 9],
				distance_coefficients_len: u8,
				distance_coefficients: [f64],
				fov: f64,
			]
	if client stop
		send stop [SEND UDP:*->M Command::Stop]

